/////////////////////////////////////////////////
// 요청과 응답에 대해 이해하기

//클라이언트가 정보를 요청하면 서버는 응답을 해야한다. 
//createServer.js 는 보면 이벤트 리스너를 가진 노드 서버를 만든것이다.

//요청에 대한 응답을 하는 부분을 채워보자
//(listen 매서드를 붙이고 클라이언트에 공개할 포트번호와 포트연결될 콜백함수를 넣자)
//server1.js 를 보자

//위의 코드에 error 이벤트 리스너를 붙여보자
//server1-0.js 를 보자
//res 객체에는 res.write와 res.end 메서드가 있는데 res.write는 클라이언트로 보낼 데이터이다.
//(여기선 HTML 문자열을 보냈지만, 버퍼를 보낼 수도 있다. 여러번 호출해서 데이터를 여러개 보낼 수도 있다.)
//res.end는 응답을 종료하는 매서드이다. 만약 인자가 있다면 그 데이터도 클라이언트로 보내고 응답을 종료한다.

//페이지는 HTML파일로 만들어서 따로 저장하는게 효율적이다. 
//server2.html  server2.js 파일을 보자

//////////////////////////////////////////////////
//쿠키와 세션 이해하기
//https://interconnection.tistory.com/74   설명이 있다.

//쿠키 : 브라우저(클라이언트) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다.
//      사용자인증이 유효한 시간을 명시할 수 있으며, 유효시간이 정해지면 브라우져가 종료되어도
//      로그인 상태가 유지되어진다.
//      쿠키는 클라이언트의 상태를 로컬에 저장했다가 참조한다.
//      Response Header에 Set-Cookie를 통해 클라이언트(브라우저)에 쿠키를 만들 수 있다.
//      쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request 시 Request Header를 넣어서 자동으로
//      서버에 전송한다.
//      set-cookie 속성에 대한 설명은 https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Set-Cookie 참조
//쿠키의 동작 방식
//1. 클라이언트가 페이지를 요청
//2. 서버에서 쿠키를 생성
//3. HTTP헤더에 쿠키를 포함시켜 응답
//4. 브라우저가 종료되어도 쿠키 만료 기간이 남아있다면 클라이언트에서 보관하고 있음.
//5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
//6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 
//  HTTP 헤더에 포함시켜 응답

//세션 : 세션은 쿠키를 기반으로 하지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와는 달리 서버에서 
//      관리를 한다.   서버에서는 클라이언트 구분을 위해 세션ID를 부여하여 웹 브라우저가 서버에 접속해서
//      브라우저를 종료할 때까지 인증상태를 유지한다.
//      세션도 접속시간에 제한을 두어 일정 시간 응답이 없으면 정보가 유지되지 않게 설정이 가능하다.
//      세션은 사용자 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만 사용자가 많아질 경우 서버 메모리를
//      많이 차지해 성능 저하의 원인이 된다.
//      클라이언트(브라우저)가 Request를 하면 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데 이것이
//      세션ID이다.  
//      (세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에 요즘은 이런 문제들을 보완한 
//      토큰 기반의 인증방식을 사용하는 추세입니다.) chap10에 설명함.
//세션의 동작 방식
//1. 클라이언트(브라우저)가 서버 접속 시 세션ID 발급
//2. 클라이언트(브라우저)는 세션ID에 대해 쿠키를 사용해서 저장 (이때 쿠키 이름은 JSESSIONID 이다.)
//3. 클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해서 세션ID 값을 서버에 전달

//쿠키 사진 넣기
//클라이언트가 처음에 요청을 하면 서버는 쿠키와 함께 응답을 한다.
//이후 쿠키와 함께 요청을 한다. 
//쿠키는 name=zerocho 같이 키-값의 쌍이다. 쿠키가 있다면 웹사이트 방문시 로그인 후 새로고침하면 
//그대로 로긴 상태로 남아있다. 서버는 쿠키를 읽고 사용자가 누군지 파악하기 때문이다.
//쿠키는 요청과 응답의 헤더에 저장된다. 
//요청과 응답은 각각 헤더와 바디를 가진다.

//server3.js   를보자
// 헤더와 바디
//요청과 응답 모두 헤더와 바디를 가지고 있다. 
//헤더 : 요청, 응답에 대한 정보를 가지고 있는 곳 (쿠키는 부가적인 정보이므로 헤더에 저장한다.)
//바디 : 서버와 클라이언트 간에 주고받을 실제 데이터를 담아두는 공간
//https://devhz.tistory.com/77 에 cookieParser() 함수를 나누는 것에 대한 자바스크립트 설명이 나와있다.

//아직까지 쿠키만 저장했을 뿐 그 쿠키가 나인지 식별해주지 못하고 있다. 다음에서 식별하는 방법을 알아보자
//server4.html    server4.js

//**쿠키를 설정할때 각종 옵션을 넣을 수 있다. 옵션간에는 ;으로 구분을 한다.
// 쿠키명=쿠키값 : 기본적인 쿠키의 값이다. mycookie=test 또는 name=zeorocho 처럼 설정한다.
// Expires=날짜 : 만료기한이다. 이 기한이 지나면 쿠키가 제거된다. default는 클라이언트가 종료될때까지이다.
// Max-age=초 : Expires와 비슷하지만 날짜 대신 초를 입력할 수 있다. 해당 초가 지나면 쿠키가 제거된다.
//              Expires보다 우선한다.
// Domain=도메인명 : 쿠키가 전송될 도메인을 지정할 수 있다. default는 현재 도메인이다.
// Path=URL : 쿠키가 전송될 URL을 지정할 수 있다. default는 / 이고 이 경우 모든 URL에서 쿠키를 전송할 수 있다.
// Secure : HTTPS일 경우에만 쿠키가 전송된다.
// HttpOnly : 설정 시 자바스크립트에서 쿠키에 접근할 수 없다. 쿠키 조작을 방지하기 위해 설정하는게 좋다.

//이제 서버가 사용자 정보를 관리하도록 코드를 바꿔보자
//server5.js
//위의 파일에서 서버에 사용자 정보를 저장하고 클라이언트(브라우저)와는 세션 아이디로만 소통한다.
//(세션 아이디는 꼭 쿠키를 사용해서 주고받지 않아도 되지만 쿠키를 사용하는 방법이 제일 간단하여 많이 사용한다.)
//실제 배포용에선 세션을 server5.js 처럼 변수에 저장하지 않는다.  서버가 멈추거나 재시작하면 메모리에 저장된 변수가
//초기화 되고 서버의 메모리가 부족하면 세션을 저장하지 못하기 때문이다.  그래서 보통 데이터베이스에 넣어둔다.
//.trim() 은 문자열의 빈공간을 없애준다.
//.map()  .reduce() 는 https://www.zerocho.com/category/JavaScript/post/5acafb05f24445001b8d796d 참조하자
//여기서 const parseCookies 변수는 cookieparser() 와 같은 기능을 해준다.

//server5.js 의 코드는 세션 아이디 값이 공개되어있어 노출될 수 있으며 다른 사람이 사용할 수 있는 보안에 취약한
//코드이다. 
//5장에서 다른사람의 코드(모듈)를 사용하는 방법에대해 6장에서 세션을 처리하는 모듈을 사용할 것이다.


////////////////////////////////////////////////////////
//REST API와 라우팅
//서버에 요청을 보낼때는 주소를 통해 요청의 내용을 표현한다. 
//주소가 /index.html 이면 서버의 /index.html를 보내달라는 뜻이다.
//요청이 주소를 통해 들어오기 때문에 서버가 이해하기 쉬운 주소를 사용하는것이 좋다.
//그래서 REST API를 이용해서 이를 바꿔보자
//REST API 는 REpresentational State Transfer의 약어이다.
//네트워크 구조의 형식중 하나로 서버의 자원을 정의하고, 자원에 대한 주소를 지정하는 방법을 가르킨다.
//주소는 의미를 명확하게 전달하기 위해 명사로 구성된다. (예를 들면 /user는 사용자 정보관련 /post는 게시글 관련)
//REST API는 주소외에도 HTTP 요청 메서드라는 것을 사용한다. 
// GET : 서버 자원을 가져오고자 할 때 사용한다. 요청의 바디에 데이터를 넣지 않는다.
//       데이터를 서버에 보낼때 쿼리스트링을 사용한다.
// POST : 서버에 자원을 새로 등록하고자 할 때 사용한다. 요청의 바디에 새로 등록할 데이터를 넣어 보낸다.
// PUT : 서버의 자원을 요청에 들어 있는 자원으로 치환하고자 할때 사용한다. 요청의 바디에 치환할 데이터를 넣어
//        보낸다.
// PATCH : 서버 자원의 일부만 수정하고자 할 때 사용한다. 요청의 바디에 일부 수정할 데이터를 넣어 보낸다.
// DELETE : 서버의 자원을 삭제하고자 할 때 사용한다.

//rest api 에 대한 사진2개 참고

//이제 REST API의 주소체계로 웹서버를 만들어보자. 
//코드를 작성하기 전에 미리 대략적인 주소를 먼저 설계하는 것이 좋다. 
// 예를 들면 아래의 주소구조를 머릿속에 정리하고 코딩하면 체계적으로 코딩을 할 수 있다.
//HTTP 메서드  | 주소          |역할
//GET         |/              |restFront.html 파일 제공
//GET         |/about         |about.html 파일 제공
//GET         |/user          |사용자 목록 제공
//GET         |기타           |기타 정적 파일 제공
//POST        |/user          |사용자 등록
//PUT         |/user/사용자id  |해당 id의 사용자 수정
//DELETE      |/uset/사용자id  |해당 id의 사용자 제거

//이제 restFront.css   restFront.html    restFront.js   about.html  restServer.js 를 통해 알아보자
// ((실행결과 사진 넣기))
//위의 사진을 보면 REST API방식으로 주소를 만들었으므로 주소만 봐도 요청 내용을 유추할 수 있다.
//Method : 요청 메소드
//Status : HTTP 응답코드
//Protocol : HTTP 프로토콜
//Type : 요청의 종류 (xhr은 AJAX요청임.)

//Network 탭에서 POST /users는 사용자를 등록하는 요청임을 알 수 있다.
//Delete /users/1558436754383 는 해당 키를 가진 사용자를 제거하는 요청이다. 
//등록, 수정 및 삭제가 발생할 때마다 GET /users로 갱신된 사용자 정보를 가져오고 있다.

//데이터는 서버가 종료되기 전까지 유지된다. 만약 데이터를 계속 유지시키고 싶으면 7,8장의 데이터베이스를 알아야한다.

/////////////////////////////////////////////////////////
//https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html  (여기서 참조함)
//REST의 구체적인 개념
//HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, 
//HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
//즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 
//HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.

//REST의 장단점
//장점
//1. HTTP 프로토클을 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
//2. HTTP 프로토클의 표준을 최대한 활용하여 여러장점을 같이 가져간다.
//3. HTTP 프로토클을 따르는 모든 플랫폼에서 사용가능하다.
//4. REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도한 바를 쉽게 파악할 수 있다.
//5. 서버와 클라이언트의 역활을 명확하게 구분한다.
//단점
//1. 표준이 존재하지 않는다.
//2. HTTP Method 형태가 제한적이다.(4가지밖에 없다.)
//3. 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URI보다 Header값이 더 어렵게 느껴진다.
//4. 구형브라우저가 아직 제대로 지원해주지 못하는 부분이 존재한다.(PUT, DELETE를 사용하지 못한다.)

//REST의 필요성
//1. 애플리케이션의 분리 및 통합
//2. 다양한 클라이언트의 등장
//   (최근의 서버프로그램은 다양한 브라우저, 안드로이드폰 같은 모바일 디바이스에서도 통신할 수 있어야 한다.)

//REST의 구성요소
//1. 자원(URI)
//   모든 자원에는 고유의 ID가 존재하고 이 자원은 Server가 존재한다.
//   자원을 구별하는 ID는 /groups/:groups_id 와 같은 HTTP URI 이다.
//   클라이언트는 URI를 이용해 자원을 지정하고, 자원의 상태에 대한 정보를 Server에 요청한다.
//2. 행위(HTTP Method)
//   HTTP 프로토콜은 GET,POST,PUT,DELETE 같은 메서드를 제공한다.
//3. 표현
//   클라이언트가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
//   REST에서 하나의 자원은 JSON,XML,TEXT,RSS등 여러형태의 Representation으로 나타내지지만 보통 JSON,XML을
//   통해 데이터를 주고받는게 일반적이다.

//REST의 특징
//1. 서버-클라이언트 구조
//   자원이 있는쪽(server), 자원을 요청하는쪽(client)가 된다.
//   REST 서버 : API를 제공하고, 비즈니스 로직 처리 및 저장을 책임진다.
//   Client : 사용자 인증이나, context(세션, 로그인정보)등을 직접 관리하고 책임진다.
//2. Stateless(무상태)
//   Client의 Context를 Server에 저장하지 않는다.
//   (쿠키나 세션같은 context정보를 신경쓰지 않아도 되므로 구현이 단순해 진다.)
//   Server는 각각의 요청을 별개로 인식하고 처리한다.(API서버는 client의 요청만을 단순히 처리한다.)
//   이전 처리요청이 다음 처리요청에 연관되어선 안된다.(Client의 요청에 따라 요청함.)
//3. Cachable(캐시처리가능)
//   웹표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 사용가능
//   HTTP가 가진 강력한 특징인 캐싱기능 사용가능
//   HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그, E-Tag를 이용하여 캐싱구현이 가능하다.
//4. 계층화
//   Client는 REST API Server만 호출한다.
//   API Server는 순수 비즈니스 로직만 수행하고, 그 앞단에 보안,로드벨런싱,암호화,사용자인증 등을 추가하여
//   구조상 유연성을 줄 수 있다. (로드밸런싱, 공유캐시를 통해 확장성,보안성을 향상시킬 수 있다.)
//   PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 이용할 수 있다.
//5. 기타
//   Server로 부터 스크립트를 받아 Client에서 실행한다.
//   HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용 가능하다.

//Caching (캐쉬)
//웹 캐쉬는 Client가 요청하는 html,image,js,css등에 대한 첫 요청시에 파일을 내려받아 특정 위치에 복사본을 저장
//(Using Space)을 하고 이후 동일한 resource 요청에 다시 내려받지않고 내부 저장한 파일을 사용하여 더 빠르게
//서비스를 할 수 있다. 서버를 통해 내려받는 양이 적어지니 응답시간이 감소하고, 네트워크 트래픽이 감소하니 
//server, client모두가 winwin이다.

//웹캐쉬의 종류
//1. Browser Caches
//   브라우저, HTTP요청을 하는 Client Application에 의해 내부 디스크에 캐쉬
//   Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache(public, private)
//   브라우저의 Back버튼 또는 이미 방문한 페이지를 재방문 할 경우 극대화
//2. Proxy Caches
//   Browser Caches와 동일한 원리로 동작하며 Client나 Server가 아닌 네트워크에서 동작
//   큰 회사나 IPS의 방화벽에 설치되며 대기시간&트래픽 감소, 접근정책&제한우회, 사용률 기록등 수행
//   한정된 수의 클라이언트를 위해 무한대의 웹서버 컨텐츠를 캐쉬
//3. Gateway Caches(Reverse, Surrogate Proxy)
//   서버 앞 단에 설치되어 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
//   Encryption/ SSL accelation, Load balancing, Serve/cache static content, Compression등을 수행
//   무한대의 클라이언트들에게 한정된 수(또는 하나)의 웹서버 컨텐츠를 제공

//캐쉬구조 및 캐쉬컨트롤
//http-cache-decision-tree.png 사진을 보자(최적의 캐쉬구조정의)
//  각 리소스들은 Cache-Control HTTP헤더를 통해 캐싱정책을 정의할 수 있다.
//  Cache-Control 지시문은 응답을 캐시할 수 있는 사용자, 해당조건 및 기간을 제어한다.
//  최적의 캐쉬성능은 서버와의 통신이 필요없는 요청이다. 응답의 로컬 복재본을 사용하면 네트워크 지연시간을
//  없애고 데이터전송에 대한 과금을 피할 수 있다. 
//no-cache , no-store
//no-cache : 응답 데이터를 캐시하고 있지만, 먼저 서버에 요청해서 유효성 검사(validation)을 하도록 강제한다. 
//응답이 로컬캐시 저장소에 저장될 수 있다. (다만 서버와 재검사를 하지 않고 캐시에서 클라이언트에 제공될 수 없다.)
//no-store : 브라우저와 모든 중간 캐시를 저장할 수 없다. 
//           응답을 캐시할 수 없으며, 매 요청마다 전체를 모두 가져와야 한다.
//public : 응답이 public으로 표시되면 이와 관련된 HTTP인증이 구성되어있고, 응답 상태 코드가 정상적으로 캐시할수 
//          없는 경우에도 캐시가 가능하다.
//private : 단일 사용자 정보가 포함된 response를 캐시한다. (userid에 따라 캐시가 response한다.)
//max-age : 캐시에 저장된 응답을 재활용할 수 있는 최대시간을 지정한다.

//https://goddaehee.tistory.com/171 (참조하기)
//응답캐싱 사진 넣기
//HTTP header를 통한 브라우저 캐싱
//1. 모든 브라우저는 HTML페이지, 자바스크립트 파일 및 이미지 같은 웹 문서의 임시저장을 위해 HTTP캐시(웹캐시)의 
//   구현을 제공한다.
//2. HTTP 헤더 지시문을 제공하여 브라우저가 응답을 캐싱할 수 있는 시기와 지속기간을 지시할 떄 사용된다.
//3. 리소스가 로컬 캐시로부터 빠르게 로드되기 때문에 점점 하드웨어 성능이 급격하게 좋아지는 지금 잘 활용하면 
//   엄청 강력한 속도를 제공한다.
//4. 요청이 네트워크를 통해 전송되지 않기 때문에 왕복시간(RTT, Round Trip Time)이 발생하지 않는다.
//5. 애플리케이션 서버 및 파이프라인의 다른 구성 요소에 대한 부하가 줄어든다.

//프록시 서버
//컴퓨터 네트워크에서 프록시 서버는 컴퓨터 시스템, 하드웨어 어플라이언스, 애플리케이션 형태로 나타난다.
//(다양한 형태의 프록시 서버가 존재한다. 사용자의 로컬컴퓨터, 네트워크 라우터, 클라이언트-대상호스트 의 중계서버)
//(모든 프록시 서버는 캐싱이 가능하다!)  종류에 대한 자세한 사항은 링크 참조

//웹캐시
//Client가 요청하는 Resource(HTML,CSS,js,image)에 대해 최초 요청시 파일을 내려받아 특정위치에 복사본을 저장.
//이후 동일한 URL의 Resource 요청은 내부에 저장된 파일(캐시)를 사용하여 더 빠르게 서비스하기 위함이다.
//서버를 통하지 않아 응답시간이 감소하고 네트워크 트래픽이 줄어들면 좋다. 하지만 잘못사용되면 고객들에게 잘못된
//정보가 전해지기 때문에 시스템 환경을 잘 분석하여 적용하는것이 중요하다.

//Header 지시문을 통한 캐싱
//모든 브라우저에는 HTTP캐시 구현이 포함되어 있기 때문에 서버응답이 브라우저에 응답할 수 있는 시점.
//그 기간을 지시하기 위한 올바른 HTTP헤더 지시문을 제공하는지 확인하면 캐시 적용이 가능하다.
//위의 설정정보는 헤더를 통해 전달할 수 있다.
//캐시 설정을 통해 브라우저에 응답으로 온 HTML,JSON 등의 이미 저장된 데이터를 통해 서버에 요청을 보내지 않고 
//사용할 수 있다.  
//일반적인 캐싱은 GET 요청에서 처리한다. 200(가져오기 성공), 301(다른 주소로 이동 후 가져옴), 404(가져올것 없음)
//상태 코드로 온 응답등을 캐싱할 수 있다.

//            |HTTP 1.0(1996년)                 |HTTP 1.1(1999년)
//            | REQUEST          | RESPONSE     | REQUEST      | RESPONSE
//validation  |If-Modified-Since |Last-Modified |If-None-Match |Entity Tag(ETag)
//freshness   |Pragma            |Expires       |Cache-Control |Cache-Control

//validation : 파일을 이전 파일과 비교하여 변경 되었는가를 체크한다.
//freshness : 캐쉬의 만료 여부를 체크한다.
//(1.1 버전이 1.0버전보다 우선순위로 작동한다.)

//웹페이지 캐시구조 사진 넣기

//Header 지시문을 통한 캐싱 문법
//캐싱문법 사진넣기
//1. Cache-Control
//  - Cache-Control Http 헤더를 통해 캐싱 정책을 정의할 수 있다.
//  - Cache-Control 지시문은 응답을 캐시할 수 있는 사용자, 해당조건 및 기간을 제어한다.
//  - Cache-Control 헤더는 HTTP/1.1 사양의 일부로 정의되었고, 응답 캐싱 정책을 정의하는데 사용된 이전 헤더(expire)를
//    대체한다.
//  - 최신 브라우저는 Cache-Control을 지원한다.
//  - Cache-Control은 응답헤더 뿐 아니라 요청헤더로도 사용할 수 있다.
//  - 프론트-중개서버-서버와 같은 구조인 경우 중개 서버에 있는 캐시를 가져오지 않도록 하려면 요청시 Cache-Control을
//    헤더로 넣어주어 해결하기도 한다.
//2. no-cache VS no-store
//  - no-cache는 캐시를 사용하지 말라는 뜻이 아닌 캐시를 쓰기전에 서버에 이 캐시를 진짜 써도되는지 물어보라는 뜻이다.
//  - no-store는 아무것도 캐싱하지 않으려면 사용하면 된다.
//3. public VS private
//  - public 일땐 공유캐시(또는 중개서버)에 저장해도 된다는 뜻이다.
//  ex) public, max-age=3600
//   max-age 로 캐시 유효시간을 지정할 수 있다. 대부분의 경우 명시적 캐싱정보(예: maxage)가 응답이 어떠한 경우든지
//   캐시가 가능하다고 나타내므로 public이 필요하지않다.
//  - private 일땐 브라우저 같은 특정 사용자 환경에만 저장하라는 뜻이다.
//   일반적으로 단일 사용자를 대상으로 하므로 중간 캐시가 이 응답을 캐시하는 것은 허용되지 않는다.
//4. must-revalidate
//  - 만료된 캐시만 서버에 확인을 받도록 한다.
//5. age
//  - 캐시 응답 때 나타나는데 max-age 시간내에서 얼마나 흘렀는지 초 단위로 알려준다.
//6. Expire
//  - cache-control 과 별개로 응답에 Expires 라는 헤더를 줄 수도 있다.
//   ex) Expire: Wed, 23 Jan 2019 03:44:00 GMT
//  - 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시된다.
//7. ETag
//  - ETag로 캐시된 응답에 대한 유효성 검사를 수행한다.(HTTP컨텐츠가 바뀌었는지를 검사할 수 있는 태그)
//  - 서버는 ETag HTTP 헤더를 사용하여 유효성 검사 토큰을 전달한다. 유효성 검사 토큰을 사용하여 리소스
//    업데이트 검사하며 리소스가 변경되지 않는 경우 데이터가 전송되지 않는다.
//  - Expire, max-age 등을 사용하여 특정 시간동안만 캐시를 사용한다고 했을 때 특정 시간, 시점이 지나야
//    브라우저가 새 요청을 발송하고 전체 새 응답을 가져온다. (그러나 리소스가 변경되지 않는 경우 이미 
//    동일한 정보를 다운로드할 필요가 없으므로 시간을 지정하여 캐시를 갱신하는 작업은 비효율적이다.)
//  - ETag 헤더에 지정된 유효성 검사 토큰은 위의 문제를 해결하기 위해 고안되었다. 서버는 일반적으로 
//    파일콘텐츠의 해시나 기타 일부 지문인 임의 토큰을 생성하고 반환한다.
//    클라이언트는 다음 요청 시 지문을 서버에 전송하기만 하면 된다. 지문이 여전히 동일한 경우 리소스가
//    변경되지 않고 이 다운로드를 건너뛸 수 있다. 
//    ex) 클라이언트에 최대 120초 동안 캐시하도록 지시하고 응답이 만료된 후 리소스가 수정되었는지 
//     확인하는데 사용할 수 있는 유효성 검사 토큰을 제공한다.
//8. If-None-Match
//  - 서버에서 ETag가 달라졌는지 검사하고 ETag가 다를 경우에만 컨텐츠를 새로 받는다.
//  - 만약 ETag가 같다면 서버는 304 Not Modified를 응답하고 캐시를 그대로 사용하게 한다.

/////////////////////////////
//https와 http2
//https 모듈은 웹 서버에 SSL암호화를 추가한다.
//GET POST로 요청을 할때 오고가는 데이터를 암호화 해서 중간에 다른 사람이 가로채도 내용을 확인할 수 없게 한다.
//로그인이나 결재가 필요한 창에서 https 적용이 필수이다. 
//server1.js 는 간단한 http 서버이다. 
//위의 서버를 암호화 하려면 https 모듈을 사용해야 한다. 
//https 모듈은 암호화를 적용하는 만큼 그것을 인증해줄 수 있는 기관이 필요하다.
//자세한건 http://mixedcode.com/Article/Index?aidx=6837 를 보면 윈도우에서 설치하는 것을 볼 수 있다.
//https://github.com/PKISharp/win-acme/releases/tag/v2.0.6.284 는 인증서 파일을 받을 수 있다.
//server1-1.js를 살펴보자
// https://www.zerocho.com/category/NodeJS/post/59f0efe01dc7c80019aca9f1  에도 자세하게 나와있다.
//server1-1.js의 creareserver 메서드는 인자를 두개 받는다. 첫번째 인자는 인증서 관련된 옵션 객체이다
//(pem,crt,key확장자를 가진 파일들이다.) 인증관련 파일의 객체들은 fs.readFileSync메서드로 읽어서
//cert, key, ca 옵션에 맞게 넣어주면 된다.
//두번쨰 인자는 http모듈과 같은 서버로직 (req,res) 이다.

//노드의 http2모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용할 수 있게 해준다.
//http/2는 요청 및 응답방식이 기존 http/1.1보다 개선되어 훨씬 효율적으로 요청을 보내고 웹의 속도도 빠르다.
//http/1.1과http/2의 비교 사진 넣기
//server1-2.js 는 http2를 적용한 것이다.



////////////////////////////////////
//cluster
//cluster 모듈은 싱글 스레드인 노드가 CPU코어를 모두 사용할 수 있게 해주는 모듈이다.
//포트를 공유하는 노드 프로세스를 여러개 둘 수 있어 요청이 많이 들어왔을 때 병렬로 실행된 서버의 갯수 만큼
//요청이 분산되게 할 수 있다. CPU 코어 하나당 프로세스 하나가 돌아가기 때문에 성능은 향상되지만, 
//프로세스간 세션을 공유하지 못하는 단점이 있다. (Redis 등의 서버를 도입해서 해결 가능!)
//레디스 서버 사용법은 아래의 주소를 참조하면 된다.
//https://www.zerocho.com/category/NodeJS/post/5a3238b714c5f9001b16c430 
//server1.js -> 클리스터링 해보자(싱글 스레드노드(프로세스1개사용) -> 프로세스 cpu 갯수만큼 사용)
//cluster.js를 보자
//직접 cluster모듈로 클러스터링을 구현해도 되지만 실무에서는 pm2 모듈로 cluster기능을 사용한다.
