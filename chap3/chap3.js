//자바스크립트는 스크립트 언어이기 때문에 미리 컴파일을 하지 않아도 즉석에서 코드를 실행할 수 있다.
//노드에서도 비슷한 콘솔을 제공하는데 이를 REPL이라 부른다.
//Read(읽고), Eval(해석하고), Print(결과물 반환하고), Loop(반복하고) 위의 과정을 REPL이라 부른다.
//터미널에서 node를 입력하고 터미널에서 코드를 쳐서 실행하는것을 REPL이라 한다.


//JS파일 실행하기
//helloWorld.js 파일을 열어보자


//모듈로 만들기
//노드는 코드를 모듈로 만들수 있다는 점에서 브라우저의 자바스크립트와는 다르다.
//모듈 : 특정한 기능을 하는 함수나 변수들의 집합이다. (예를 들면 수학에 관련된 함수만 모아서 모듈을 만들 수 있다.)
//var.js / func.js / index.js 를 보자
//var.js : 변수 2개 선언 module.exports로 변수를 넘긴다. 
//func.js : require로 var.js에서 변수를 가져와서 함수를 만든 후 module.exports로 함수를 넘긴다.
//index.js : var.js func.js 모두 가져와서 사용한다.


////////////////////////////
//노드 내장 객체 알아보기
//global 객체
// -> 브라우저의 window같은 전역 객체이다. (전역객체이므로 모든 파일에 접근할 수 있다.)
//window.open 메서드를 그냥 open으로 호출하는 것처럼 global도 생략할 수 있다.
//콘솔창에 node 를 치고 그다음에 global을 치면 global에 내장된 속성을 볼 수 있다.
//globalA.js   globalC.js 를 생성해서 global 객체를 생성 후 message에 속성을 넣고 넘겨서
//출력해보자
//*global 객체를 남용하면 나중에 유지보수가 어려워지는 것을 잊지 말자


//console
// console 역시 window 대신 global 객체 안에 들어있다.
//console 객체는 보통 디버깅을 위해 사용된다. 
//1. 개발 중 변수에 값이 제대로 들어갔는지 확인하기 위해 사용하거나 
//2. 코드실행 시간을 알아볼때 사용
//3. 에러발생시 에러내용 표시하기 위해 사용
//console.js를 보자
//console.time(레이블) : console.timeEnd(레이블)과 대응되어 같은 레이블을 가진
//                       time과 timeEnd 사이의 시간을 측정한다. (레이블을 일치해야한다.)
//console.error(에러내용) : 에러를 콘솔에 표시한다.
//console.dir(객체, 옵션) : 객체를 콘솔에 표시한다. 첫번째로 표시할 객체, 두번째는 옵션을 넣는다.
//                          옵션의 colors = true 로 하면 콘솔에 출력될때 색이 추가된다.
//                          depth는 객체 안의 프로퍼티 or 객체를 몇단계까지 보여줄지 결정한다. (기본값은 2이다.)
//console.trace(레이블) : 에러가 어디서 발생했는지 추적할 수 있게 해준다. 보통 에러발생시 에러의 위치가 나오기
//                          때문에 많이 안쓰이지만 안나올땐 이걸 쓰면 된다.


//타이머
//타이머 기능을 제공하는 함수인 setTimeout, setInterval, setImmediate는 노드에서 window 대신 global객체 안에있다.
//setTimeout(콜백 함수, 밀리초) : 주어진 밀리초(1/1000) 이후에 콜백함수를 실행한다.
//setInterval(콜백 함수, 밀리초) : 주어진 밀리초(1/1000)마다 함수를 반복실행한다.
//setImmediate(콜백 함수) : 콜백함수를 즉시 실행한다.
//타이머는 모두 아이디를 리턴한다. 아이디를 사용하여 타이머를 취소할 수 있다.
//clearTimeout(아이디) : setTimeout을 취소한다.
//clearInterval(아이디) : setInterval을 취소한다.
//clearImmediate(아이디) : setImmediate를 취소한다.
//자세한건 timer.js 에서 보자
//**setImmediate(콜백) , setTimeout(콜백,0)
//-> 파일시스템 접근, 네트워킹 같은 I/O작업의 콜백함수 안에서 타이머를 호출하는 경우 
//   보통 setImmediate(콜백)이 setTimeout(콜백, 0) 보다 먼저 호출되지만 항상 그런건 아니다.
//  그러므로 setTimeout(콜백,0)의 사용은 권장하지 않는다.


//__filename, __dirname
//파일명과 파일의 경로에 대해 알려준다.
//__filename : 실행파일의 위치 
//__dirname : 해당 파일의 위치
//filename.js 를 보자


//module, exports
//exports와 module.exports의 관계
//        참조                참조
// exports --> module.exports --> {}
//
//위와 같은 참조관계가 있기 때문에 한 모듈에 exports 객체와 module.exports 객체를 동시에 사용하는건 좋지않다.
//module.exports : 어떤 값이든 대입해도 된다.
//exports : 반드시 객체처럼 속성명과 속성값을 대입해야한다.
//          (exports에 다른 값을 대입하면 객체의 참조 관계가 끊겨 더이상 모듈로 기능하지 않는다!)
//var.js를 보면 이부분이 나온다.


//process
//process객체는 현재 실행되고 있는 노드 프로세스에 대한 정보를 담고 있다.
//node를 터미널에 입력해서 REPL를 이용해보자
//process.cpuUsage()    //현재 CPU 사용량이다.
//process.env : 입력하면 매우 많은 정보가 출력되는데 이 정보들은 환경변수들이다.
//              process.env는 서비스의 중요한 키를 저장하는 공간으로도 사용된다.
//              서버나 데이터베이스의 비밀번호와 각종 API키를 코드에 직접 입력하는건 위험하다.
//              그래서 보통 중요한 비밀번호는 아래와 같이 쓰이기도 한다.
// const secretId = process.env.SECRET_ID;
// const secretCode = process.env.SECRET_CODE;

//process.nextTick(콜백)
//이벤트 루프가 다른 콜백 함수들보다 nextTick의 콜백함수를 우선으로 처리하도록 만든다.
//nextTick.js 를 보자

//테스크와 마이크로테스크 사진 넣기(책에 있는 사진 찍어서 넣기 p91)

//process.nextTick(마이크로테스크 큐에 포함됨)은 setImmediate, setTimeout(테스크 큐에 포함됨)보다
//먼저 실행된다. 
//(process.nextTick으로 받은 콜백함수)나 (resolve된 Promise)는 다른 이벤트루프에서 대기하는 콜백
//함수보다 먼저 실행된다.  그래서 비동기처리로 setImmediate보단 process.nextTick을 더 선호하는 개발자도
//있지만 이런 microtask를 재귀호출하게되면 이벤트 루프는 다른 콜백함수보다 Microtask를 우선시하여 콜백함수들이
//실행되지 않을 수도 있다.

//process.exit
//서버에 이코드를 넣으면 서버가 멈추기 때문에 서버에서는 안쓰고, 수동적으로 노드를 멈추게하기 위해 쓴다.
//exit.js 를 보자


///////////////////
//내장모듈 사용하기
//OS
//웹 브라우저에서 사용되는 자바스크립트는 운영체제의 정보를 가져올 순 없지만, 노드는 os모듈에 정보가 담겨있어
//정보를 가져올 수 있다.
//os.js를 보자
//os.arch() : x64 운영체제 비트
//os.type() : 운영체제의 종류
//os.uptime() : 운영체제 부팅이후 흐른 시간(초) process.uptime() 은 노드의 실행시간이었다
//os.release() : 운영체제의 버전
//os.homedir() : 홈디렉토리의 경로
//os.tmpdir() : 임시파일저장 경로
//os.cpus() : 컴퓨터의 코어 정보를 보여준다.
//os.freemem() : 사용가능한 메모리
//os.totalmem() : 전체 메모리 용량
//* 코어의 갯수는 os.cpus().length로 확인이 가능하다. cluster 모듈에서 코어의 개수에 맞춰 프로세스 갯수를 
//  늘릴 수 있다.

//path
//폴더와 파일의 경로를 쉽게 조작하도록 도와주는 모듈이다.
//path모듈이 필요한 이유 중 하나는 운영체제별로 경로 구분자가 다르기 때문이다.
//path.js 파일을 보자


//URL
//인터넷 주소를 쉽게 조작하도록 도와주는 모듈이다.
// 사진추가(whattwg와 노드의 주소 체계) 사진에서 위쪽이 기존 노드의 url 아래가 WHATWG의 url 이다
//url.js 를 보자
//url.parse(주소) : 주소를 분해한다. 
//                  WHATAG 방식과 비교하면 username, password -> auth 속성이 있고,
//                                        searchParams -> query 가 있다.
//url.format(객체) : 분해되었던 url 객체를 다시 원래 상태로 조립한다. 
//                  (WHATAG 방식 url, 노드방식 url 둘다 사용가능)
//*주소가 host 부분 없이 pathname 부분만 오는 경우(예를 들면 /book/booklist.apsx) WHATAG는 이 방식을 
// 처리할 수 없다. 서버를 만들때 host 부분없이 오는 주소를 볼 것이다.
// WHATAG 방식은 search 부분을 searchParams라는 특수한 객체로 리턴하기 때문에 유용하다.
//search부분은 보통 주소를 통해 데이터를 전달할 떄 사용된다.
//(예를 들면 'http://www.gilbut.co.kr/?page=3&limit=10&category=nodejs&category=javascript' 에서
// ?page=3&limit=10&category=nodejs&category=javascript 부분처럼 ? 뒤에 키=값 이렇게 연결된 부분이다.)
//searchParams.js 에서 살펴보자(searchParams에 대해 알아보자)
//*다른 것들은 뭐 당연한거라 몰랐던 부분만 적어보자
//seachParams에서 myURL객체 안의 메서드중
//set(키, 값) : append와 비슷하지만 같은 키 값들을 모두 지우고 새로 추가한다.
//toString() : 조작한 searchParams 객체를 다시 문자열로 만든다. 이 문자열을 search에 대입하면 
//              주소 객체가 반영된다.
//searchParams가 query 같은 문자열보다 더 나은 이유가 querystring 모듈은 한번 더 써야하기 때문이다.


//querystring
//WHATAG url이 아닌 노드 url을 사용할때 search 부분을 사용하기 쉽게 객체로 만드는 모듈이다.
//querystring.js 를 살펴보자
//querystring.parse(쿼리) : url의 query부분을 자바스크립트 객체로 분해준다.
//querystring.stringfy(객체): 분해된 query객체를 다시 문자열로 조립해준다.


//crypto
//다양한 방식의 암호화를 도와주는 모듈이다.
//비밀번호를 암호화해서 저장할 때 쓰인다.
//
//단반향 암호화
// 고객 --> 로그인위한 암호 입력
// DB   --> 로그인 비밀번호 
//위의 두개를 그냥 암호화만해서 비교하면 된다. 그래서 굳이 복호화는 필요없다.
//단방향 암호화 알고리즘은 주로 해시 기법을 사용한다.
//해시 기법 : 어떠한 문자열을 고정된 길이의 다른 문자열로 바꿔버리는 방식
//(예를 들면 abcdefgh 문자열 -> qvew , ijkim -> zvsf 
// 처럼 입력 문자열 길이는 다르지만 출력 문자열의 길이는 4자리로 고정된 것이다.)
//hash.js를 살펴보자
//createHash(알고리즘) : 사용할 해시 알고리즘을 넣어준다.
//                      (md5,sha1,sha256,sha512등이 있다. md5,sha1은 보안이 취약함.)
//update(문자열) : 리턴할 문자열을 넣어준다.
//digest(인코딩) : 인코딩할 알고리즘을 넣어준다. base64, hex, latin1이 주로 있는다. base64가
//                  문자열이 짧아 많이 쓴다.
//pbkdf2, bcrypt, scrypt 라는 알고리즘이 요즘 많이 쓰이고 있다.
//pbkdf2는 기존 문자열에 salt라고 불리는 문자열을 붙인 후 해시 알고리즘은 반복해서 적용하는 것이다.
//pbkdf2.js 에서 살펴보자
//위의 보안이 취약하다고 생각되면 scrypt방식을 사용하면 된다.


//양방향 암호화
//암호화된 문자열을 복호화 할 때 키(열쇠)가 사용된다. 암호를 복호화할때는
//암호화 시 사용할 키 = 복호화 시 사용할 키  되어야 가능하다.
//cipher.js 를 보자


//util
//util은 각종 편의 기능을 모아둔 모듈이다.
//(계속해서 API가 추가되고 있지만, deprecated 되어 사라지는 경우도 있다.)
//deprecated : 중요도가 떨어져서 더이상 사용되지 않고 앞으로는 사라지게 될것(프로그래밍 언어)
//util.js 를 살펴보자
//util.deprecate : 함수가 deprecated 처리되었음을 알려준다.
//                  첫번째 인자로 넣은 함수를 사용할 때 경고 메시지가 출력된다.
//                  두번째 인자는 출력할 메시지 내용을 입력하면 된다.
//util.promisfy : 콜백 패턴 -> 프로미스 패턴 
//                  이렇게 바꿔도면 async/await 패턴까지 사용하기 편하다.



//////////////////////////////////////////
//파일 시스템 접근하기
//fs 모듈은 파일시스템에 접근하는 모듈이다. 
//즉 파일을 생성하거나 삭제하고, 읽거나 쓸 수 있다. 폴더 역시 마찬가지이다.
//readme.txt  , readFile.js 두개를 살펴보자
//writeFile.js 에서 파일을 만들어보자


//동기 메서드와 비동기 메서드
//fs모듈이 가진 비동기 메서드를 보자
//readme2.txt    async.js 파일을 살펴보자
//async.js 를 실행하면 돌릴때마다 다르게 나오는것을 볼 수 있다.
//동기와 비동기, 블로킹과 논블로깅에 대해서
//-> 노드에서는 동기-블로킹, 비동기-논블로킹 방식으로 작동한다.
//동기와 비동기 : 함수가 바로 return 되는지 여부
//블로킹과 논블로킹 : 백그라운드 작업 완료 여부
//(동기_블로킹,비동기_논블로킹 사진 넣기)
//sync.js 에서 동기화의 예시를 보자
// 비동기식으로 순서대로 출력하는 방법을 보자
//asyncOrder.js 를 보자


//버퍼와 스트림 이해하기
//노드의 버퍼 : 노드는 파일을 읽을 떄 메모리에 파일 크기만큼 공간을 마련해두며, 파일 데이터를 메모리에
//              저장한 뒤 사용자가 조작할 수 있도록 해준다.
//노드의 스트림 : readFile 방식의 버퍼가 편리하긴 하지만 용량이 100MB면 그 파일 읽거나 작업을 할 때
//                메모리에 100MB의 버퍼를 만들어야 한다. 서버같이 많은 사람들이 이용하게 되면 문제가 커진다.
//                 스트림은 버퍼의 크기를 작게 만들어서 여러번에 보내는 방식이다.
//                 예를 들면 1MB의 파일을 100번 보내서 100MB 파일을 전송할 수 있다.
//
//원본 데이터 ---> 버퍼 ---> 데이터 전송됨
//위의 방식으로 데이터가 옮겨진다.
//버퍼를 직접 다룰 수 있는 클래스가 있다.
//buffer.js를 살펴보자
//from(문자열) : 문자열을 버퍼로 바꿔준다.
//toString(버퍼) : 버퍼 -> 문자열 hex,base64를 넣으면 그렇게 바뀐다.
//concat(배열) : 배열안의 버퍼를 합친다.
//alloc(바이트) : 빈 버퍼를 생성한다. 바이트를 인자로 지정해주면 해당 버퍼가 생성된다.

//원본 데이터 ---> 버퍼를 잘게 쪼개줌 ---> 쪼개진 버퍼 모음 ---> 데이터 전송됨
//readme3.txt    createReadStream.js 를 살펴보자
//createWriteStream.js 에서 스트림을 이용하여 파일을 써보자
//createReadStream으로 파일을 읽고 createWriteStream으로 쓰는것도 가능하다. 
//파일 복사와 같다. pipe 를 이용해서 해보자
//readme4.txt     pipe.js 를 보자
//pipe()는 따로 on('data'), writeStream.write()를 사용하지 않아도 알아서 전달이 된다.
//노드는 파일을 압축하는 zlib 이라는 모듈도 있다. 
//readStream, writeStream을 이용하여 기존의 파일을 압축해보자
//gzip.js 를 보자


//기타 fs 메서드
//fs.access(경로, 옵션, 콜백) : 폴더나 파일에 접근할 수 있는지 체크한다.
//                             두번째 인자는 상수로 
//                      F_OK : 파일존재여부 , R_OK : 읽기권한여부, W_OK : 쓰기권한여부
//                      파일/폴더 권한이 없다면 에러발생.. 에러코드는 ENOENT이다.
//(fs.constants.F_ok 에서 fs.constants 는 보통 file system operation에서 사용되는 변수들의 객체를 리턴해준다.)
//
//fs.mkdir(경로. 콜백) : 폴더를 만드는 메서드. 이미 폴더가 있으면 에러발생.(access로 먼저 확인할것)
//fs.open(경로, 옵션, 콜백) : 파일의 아이디(fd 변수)를 가져오는 메서드이다. (예제에서 fd변수임.)
//                      파일이 없다면 파일을 생성한 후 그 아이디를 가져온다.
//                      가져온 아이디(fd변수)를 이용하여 fs.read(), fs.write() 도 사용 가능하다.
//                      옵션은 w : 쓰기, r : 읽기, a : 기존 파일에 추가 
//                      예제에서는 w 이므로 파일이 없을 때 새로 생성함. 
//                      (r 이었으면 에러발생(기존파일이x 때문))
//fs.rename(기존 경로, 새 경로, 콜백) : 파일의 이름을 바꾸는 메서드
//fsCreate.js 를 보자(위에 정리한 메서드들이 들어감)
//fs.readdir(경로, 콜백) : 폴더 안의 내용물을 확인할 수 있다. 배열안에 내부 파일과 폴더명이 나온다.
//fs.unlink(경로, 콜백) : 파일을 지울 수 있다. 폴더 안에 파일이 없으면 에러가 발생한다.(꼭 확인하자)
//fs.rmdir(경로, 콜백) : 폴더를 지울 수 있다. 폴더 안에 파일이 있다면 에러가 발생하므로 먼저 내부파일을
//                      지우고 폴더를 지워야 한다.
//fsDelete.js 에서 폴더 내용 확인 및 삭제를 해보자
//또한 node8.5 이후 파일 복사 메서드가 생겨 createReadStream.pipe(createWriteStream) 을 쓸 필요가 없어졌다.
//copyFile.js 를 보자



////////////////////////////////
// 이벤트 이해하기
//스트림에서 on('data', 콜백)   on('end',콜백) 을 사용하여 data, end 이벤트가 발생할 때 콜백함수를 
//호출하게 만들었다. 
//event.js 를 통해 이벤트를 직접 만들어보자
//on(이벤트명, 콜백) : 이벤트 이름과 이벤트 발생 시의 콜백을 연결해준다.(이벤트를 만든다!!정의 해줌)
//                  event2 처럼 이벤트 하나에 이벤트 여러개를 달아줄 수 있다.
//addListener(이벤트명. 콜백) : on과 기능이 같다.
//emit(이벤트명) : 이벤트를 호출하는 메서드이다. 이벤트 이름을 인자로 넣으면 미리 등록된 이벤트 콜백이 실행된다
//                 ((emit에서 이밴트를 발생시키고 on에서 이벤트를 받아서 on의 내부 콜백 실행된다.))
//once(이벤트명, 콜백) : 한번만 실행되는 이벤트이다. 
//                      myEvent.emit('event3') 을 두번 호출했지만, 콜백은 한번만 실행되었다.
//removeAllListener(이벤트명) : 이벤트에 연결된 모든 이벤트 리스너를 제거한다. 
//                              event4가 호출되기 전에 리스너를 제거했기 때문에 event4가 호출되지 않는다.
//off(이벤트명, 콜백) : removeListener와 기능이 같다.
//listenerCount(이벤트명) : 현재 리스너가 몇 개 연결되었는지 확인한다.



///////////////////////////////////
//예외처리하기
//노드는 싱글스레드이기 때문에 예외처리가 정말 중요하다.
//error1.js 를 살펴보자
//error2.js 를 살펴보자(노드상에서 에러 잡는법)
//error3.js 를 살펴보자(예측 불가능한 에러를 처리하는 법)
//error3.js에서의 uncaughtException 이벤트 리스너는 모든 에러를 처리할것처럼 보이지만 노드공식문서에서는 
//uncaughtException를 최후의 수단으로 사용하는 것을 권한다.
//노드는 uncaughtException 이벤트 발생 후 다음 동작이 제대로 동작하는지를 보증하지 않는다.
//(즉, 복구 작업 코드를 넣었다고 해도 그것이 동작하는지 확신할 수 없다.)
//process.exit()로 프로세스를 종료하고 에러는 단순히 기록하는 정도로 사용하자! 
